#!/usr/bin/env python
# koan = kickstart over a network
# a tool for network provisioning of Xen and network re-provisioning
# of existing Linux systems.
#
# Michael DeHaan <mdehaan@redhat.com>

# TODO list:
# xenguest-install --> libvirt + testing
# autoks support + testing
# http support
# xml format standardization (mostly a cobbler issue)

import sys
import os
import socket
import yaml       # not in fc5.  should be.  or a fixed py-syck, one...
import traceback
import time
import urlgrabber
import optparse
import exceptions
"""
koan --xen --profiles=webserver,dbserver --server=hostname
koan --replace-self --with-extreme-prejudice --server=hostname --profiles=foo
"""

class InfoException(exceptions.Exception):
    def __init__(self,args=None):
        self.args = args

class Koan:
 
    def __init__(self,args):
        """
        Constructor.  Arguments are those from optparse...
        """
        self.server            = args.server
        self.profiles          = args.profiles
        self.verbose           = args.verbose
        self.is_xen            = args.is_xen
        self.is_auto_kickstart = args.is_auto_kickstart
        self.is_forced         = args.is_forced
        self.last_error = ""
        if self.server is None:
            raise InfoException, "no --server specified"
        if not self.is_xen and not self.is_auto_kickstart:
            raise InfoException, "must use either --xen or --replace-self"
        elif self.is_auto_kickstart and not self.is_forced:
            raise InfoException, "This system will likely be destroyed.  To confirm, you must specify --with-extreme-prejudice"
        if not self.server:
            raise InfoException, "no server specified"
        if self.verbose is None:
            self.verbose = True
        if not self.profiles:
            raise InfoException, "must specify --profiles"
        self.profiles = self.profiles.split(',')
        if self.is_xen:
            self.do_xen()
        else:
            self.do_auto_kickstart()

    def debug(self,msg):
        if self.verbose:
            print "- %s" % msg
    
    def do_net_install(self,download_root,each_profile):
        """
        Actually kicks off downloads and xen installs
        """
        for profile in self.profiles:
            self.debug("processing profile: %s" % profile)
            profile_data = self.get_profile_yaml(profile)
            self.debug(profile_data)
            if not 'distro' in profile_data:
                raise InfoException, "invalid response from boot server"
            distro = profile_data['distro']
            distro_data = self.get_distro_yaml(distro)
            self.debug(distro_data)
            self.get_distro_files(distro_data, download_root)
            each_profile(self, distro_data, profile_data)
    
    def do_xen(self):
        def each_profile(self, distro_data, profile_data):
            cmd = self.build_xen_args(profile_data, distro_data)
            self.invoke_xen_install(cmd) 
        self.do_net_install("/tmp",each_profile)

    def do_auto_kickstart(self):
        def each_profile(self, distro_data, profile_data):
            if not os.path.exists("/sbin/grubby"):
                raise InfoException, "grubby is not installed"
            args = (distro_data['kernel_local'],
                    distro_data['initrd_local'],
                    distro_data['kernel_options'],
                    profile_data['kickstart'])
            cmd = "/sbin/grubby --add-kernel %s --initrd %s --make-default --title 'kickstart' --args '%s ks=%s' --copy-default" % args
            self.debug("editing boot: %s" % cmd)
            try:
                os.system(cmd)
            except:
                raise InfoException, "error while running /sbin/grubby"
            self.debug("rebooting")
            # os.system("/sbin/shutdown -r -t 5 -k") # remove -k
        self.do_net_install("/tmp",each_profile) # FIXME: should be /boot

    def get_profile_yaml(self,profile_name):
        """
        Fetches profile yaml from a from a remote bootconf tree.
        """
        self.debug("fetching configuration for profile: %s" % profile_name)
        try:
            url = "http://%s/cobbler/profiles/%s" % (self.server,profile_name)
            self.debug("url=%s" % url)
            data = urlgrabber.urlread(url)
            return yaml.load(data).next()
        except:
            traceback.print_exc() # debug
            raise InfoException, "couldn't download profile information: %s" % profile_name

    def get_distro_yaml(self,distro_name):
        """
        Fetches distribution yaml from a remote bootconf tree.
        """
        self.debug("- fetching configuration for distro: %s" % distro_name)
        try:
            url = "http://%s/cobbler/distros/%s" % (self.server,distro_name)
            self.debug("url=%s" % url)
            data = urlgrabber.urlread(url)
            return yaml.load(data).next()
        except:
            raise InfoException, "couldn't download distro information: %s" % distro_name 

    def get_distro_files(self,distro_data, download_root):
        """
        Using distro data (fetched from bootconf tree), determine
        what kernel and initrd to download, and save them locally.
        """
        distro = distro_data['name']
        kernel = distro_data['kernel']
        initrd = distro_data['initrd']
        kernel_short = os.path.basename(kernel)
        initrd_short = os.path.basename(initrd)
        kernel_save = "%s/%s" % (download_root, kernel_short)
        initrd_save = "%s/%s" % (download_root, initrd_short)
        try:
            self.debug("downloading initrd %s to %s" % (initrd_short, initrd_save))
            url = "http://%s/cobbler/images/%s/%s" % (self.server, distro, initrd_short)
            self.debug("url=%s" % url)
            urlgrabber.urlgrab(url)
            self.debug("downloading kernel %s to %s" % (kernel_short, kernel_save))
            url = "http://%s/cobbler/images/%s/%s" % (self.server, distro, kernel_short) 
            self.debug("url=%s" % url)
            urlgrabber.urlgrab(url)
        except:
            raise InfoException, "error downloading files"
        distro_data['kernel_local'] = kernel_save
        distro_data['initrd_local'] = initrd_save

    def build_xen_args(self,profile_data,distro_data):
        """
        Probably obsolete.  Refactor out.
        """
 

        #pd = profile_data
        #dd = distro_data
        #args = [
        #    self.xenguest_install,
        #    "--name=%s"     % self.calc_xen_name(pd),
        #    "--file=%s"     % self.calc_xen_filename(pd),
        #    "--file-size=%s" % self.calc_xen_filesize(pd),
        #    "--ram=%s"      % self.calc_xen_ram(pd),
        #    "--location=file://%s,%s" % (dd['initrd_local'],dd['kernel_local'])
        #] 
        # optional opts
        #if pd['xen_paravirt']:
        #    args.append("--paravirt")
        #if pd['kickstart'] != "" or pd['kernel_options'] != "":
        #    extra = " -x "
        #    if pd['kickstart'] != "":
        #        extra = extra + "ks=" + pd['kickstart']
        #    if pd['kickstart'] !="" and pd['kernel_options'] !="":
        #        extra = extra + ","
        #    if pd['kernel_options'] != "":
        #        extra = extra + pd['kernel_options']
        #    args.append(extra)
        # FIXME: support MAC ranges in addition to specifics
        #if pd['xen_mac'] != "":
        #    args.append("--mac=%s" % pd['xen_mac'])
        #return " ".join(args)
        
        raise InfoException, "Implementation TBA"
        return ""    

    def invoke_xen_install(self,cmd):     
        """
        Install Xen based on the downloaded parameters
        """
        #self.debug("running %s" % cmd)
        #rc = os.system(cmd)
        #if not rc == 0:
        #    raise "%s failed (rc=%d)..." % (self.xenguest_install, rc)
        #return True

        # FIXME: This should call libvirt

        return True

    def calc_xen_name(self,data):
        """
        Turn the suggested name into a non-conflicting name.
        For now we're *really* lazy about this and are just taking on
        the epoch. FIXME.
        """
        name = data['xen_name']
        if name is None or name == "":
            name = "xenguest"
        name = data['xen_name'] + str(int(time.time()))
        data['xen_name'] = name
        return name

    def calc_xen_filename(self,data): 
        """
        Determine where to store the Xen file.  Just base this off
        the name and put everything close to the other Xen files?
        """
        if not os.path.exists("/var/lib/xenimages"):
             try: 
                 os.mkdir("/var/lib/xenimages")
             except: 
                 pass
        return os.path.join("/var/lib/xenimages","%s.disk" % data['xen_name'])

    def calc_xen_filesize(self,data):
        """
        Assign a xen filesize if none is given in the profile.
        """
        size = data['xen_file_size']
        err = False
        try:
            int(size)
        except:
            err = True
        if int(size)<1:
            err = True
        if err:
            self.debug("invalid file size specified, defaulting to 1 GB")
            return 1
        return int(size)

    def calc_xen_ram(self,data):
        """
        Assign a xen ram size if none is given in the profile.
        """
        size = data['xen_ram'] 
        err = False
        try:
            int(size)
        except:
            err = True
        if int(size) < 256:
            err = True
        if err:
            self.debug("invalid RAM size specified, defaulting to 256 MB")
            return 256
        return int(size)
 

if __name__ == "__main__":
    """
    Command line stuff...
    """
    if os.getuid() != 0:
        print "koan requires root access"
        sys.exit(3)
    p = optparse.OptionParser()
    p.add_option("-x", "--xen",
                 dest="is_xen",
                 action="store_true",
                 help="requests new Xen guest creation")
    p.add_option("-r", "--replace-self",
                 dest="is_auto_kickstart",
                 action="store_true",
                 help="requests re-provisioning of this host")
    p.add_option("-F", "--with-extreme-prejudice",
                 dest="is_forced",
                 action="store_true",
                 help="required with --replace-self for safety reasons")
    p.add_option("-p", "--profiles", 
                 dest="profiles", 
                 help="list of profiles to install")
    p.add_option("-s", "--server", 
                 dest="server", 
                 help="specify the cobbler server")
    p.add_option("-q", "--quiet",
                 dest="verbose",
                 action="store_false",
                 help="run (more) quietly")
    (options, args) = p.parse_args()
    # FIXME:  catch custom exceptions only...
    try:
        Koan(options)
        sys.exit(0)
    except InfoException, ie:
        traceback.print_exc()
        # print str(ie)  # str.message() ... FIXME
        sys.exit(1)
    except:
        traceback.print_exc()
        sys.exit(2)

