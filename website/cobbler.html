<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>NAME</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#cobbler_usage">COBBLER USAGE</a></li>
	<ul>

		<li><a href="#setup">SETUP</a></li>
		<li><a href="#adding_a_distribution">ADDING A DISTRIBUTION</a></li>
		<li><a href="#adding_a_profile">ADDING A PROFILE</a></li>
		<li><a href="#adding_a_system">ADDING A SYSTEM</a></li>
		<li><a href="#adding_a_repository_to_mirror">ADDING A REPOSITORY TO MIRROR</a></li>
		<li><a href="#displaying_configuration_entries">DISPLAYING CONFIGURATION ENTRIES</a></li>
		<li><a href="#deleting_configuration_entries">DELETING CONFIGURATION ENTRIES</a></li>
		<li><a href="#rebuilding_configurations">REBUILDING CONFIGURATIONS</a></li>
	</ul>

	<li><a href="#examples">EXAMPLES</a></li>
	<ul>

		<li><a href="#import_workflow">IMPORT WORKFLOW</a></li>
		<li><a href="#normal_workflow">NORMAL WORKFLOW</a></li>
		<li><a href="#repository_mirroring_workflow">REPOSITORY MIRRORING WORKFLOW</a></li>
		<li><a href="#xen">XEN</a></li>
	</ul>

	<li><a href="#advanced_topics">ADVANCED TOPICS</a></li>
	<ul>

		<li><a href="#pxe_menus">PXE MENUS</a></li>
		<li><a href="#kickstart_templating">KICKSTART TEMPLATING</a></li>
		<li><a href="#dhcp_configuration_management">DHCP CONFIGURATION MANAGEMENT</a></li>
		<li><a href="#enchant">ENCHANT</a></li>
		<li><a href="#importing_trees">IMPORTING TREES</a></li>
		<li><a href="#default_pxe_boot_behavior">DEFAULT PXE BOOT BEHAVIOR</a></li>
		<li><a href="#repo_management">REPO MANAGEMENT</a></li>
		<li><a href="#kickstart_tracking">KICKSTART TRACKING</a></li>
		<li><a href="#tweaking">TWEAKING</a></li>
		<li><a href="#api">API</a></li>
	</ul>

	<li><a href="#exit_status">EXIT_STATUS</a></li>
	<li><a href="#author">AUTHOR</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>cobbler is a command line tool for configuring a provisioning and update server.  It supports provisioning via PXE, virtualization (Xen), and remotely re-provisioning a existing Linux system when PXE booting isn't possible.  The latter two features are enabled by usage of 'koan' (a client side provisioning application) on the remote system.  Update server features include yum mirroring over rsync:// and integration of those mirrors with kickstart.</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>cobbler command [subcommand] [--arg1=] [--arg2=]</p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Cobbler manages provisioning using a tiered concept of Distributions, Profiles, Systems, and Repositories.</p>
<p>Distributions contain information about what kernel and initrd are used, along with various other information, such as required kernel parameters.</p>
<p>Profiles associate a Distribution with a kickstart file and optionally customize it further.</p>
<p>Systems associate a hostname, IP, or MAC with a distribution and optionally customize the Profile further.</p>
<p>Repositories contain yum mirror information.  Using cobbler to mirror repositories is an optional/advanced 
feature and is covered further down in this manpage.</p>
<p>The main advantages of cobbler is that it glues together a lot of disjoint technologies and concepts and abstracts the user from the need to understand them.   It allows the systems administrator to concentrate on what he needs to do, and not how it is done.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p>For help in building kickstarts, try using the ``system-config-kickstart'' tool, or install a new system and look at the /root/anaconda-ks.cfg file left over from the installer.  General kickstart questions can also be asked at <a href="mailto:kickstart-list@redhat.com.">kickstart-list@redhat.com.</a>  Cobbler ships some kickstart templates in /etc/cobbler that may also prove helpful.</p>
<p>
</p>
<hr />
<h1><a name="cobbler_usage">COBBLER USAGE</a></h1>
<p>
</p>
<h2><a name="setup">SETUP</a></h2>
<p>Running ``cobbler check'' after installation will verify that cobbler's prerequisites are installed and configured correctly.  This is a good first command to run after installing cobbler.</p>
<p>Any problems detected should be corrected, with the potential exception of DHCP related warnings.  Run ``cobbler sync'' after making any changes to the configuration files to ensure those changes are applied.</p>
<p>It is especially important that the server name field be accurate in /var/lib/cobbler/settings, without this field being correct, kickstart trees may not be found, and provisioning won't work.</p>
<p>For PXE, if DHCP is to be run from the cobbler server, the dhcp configuration file should be changed as suggested.  If DHCP is not run locally, the ``next-server'' field on the DHCP server should point to the cobbler server's IP and the filename should be set to ``pxelinux.0''.</p>
<p>Cobbler can also manage (generate) your dhcp configuration file -- this is covered in a later section.  If you don't already have a dhcp setup, allowing cobbler to manage it may prove to be useful.  If you already have a setup, moving an existing setup to be managed from within cobbler is relatively painless and is entirely optional.</p>
<p>
</p>
<h2><a name="adding_a_distribution">ADDING A DISTRIBUTION</a></h2>
<p>This first step towards configurating what you want to provision is to add a distribution to the cobbler's configuration.</p>
<p>If there is an rsync mirror or filesystem tree that you would rather import instead, skip down to the documentation about the ``import'' command.  It's really a lot easier, but it requires waiting for the mirror to sync data across, or using a mounted DVD (or DVD image) you might have lying around.  Imported distros also save time during install since they don't have to hit external install sources.</p>
<p>The manual distro add command is:</p>
<p><strong>cobbler distro add --name=string --kernel=path --initrd=path [--kopts=string] [--ksmeta=string] [--arch=x86|x86_64|ia64] [--breed=redhat|suse]</strong></p>
<dl>
<dt><strong><a name="item_name">name</a></strong>

<dd>
<p>a string identifying the distribution, this should be something like ``rhel4''.</p>
</dd>
</li>
<dt><strong><a name="item_kernel">kernel</a></strong>

<dd>
<p>an absolute filesystem path to a kernel image</p>
</dd>
</li>
<dt><strong><a name="item_initrd">initrd</a></strong>

<dd>
<p>an absolute filesystem path to a initrd image</p>
</dd>
</li>
<dt><strong><a name="item_kopts">kopts</a></strong>

<dd>
<p>(optional) sets kernel command-line arguments that the distro, and profiles/systems dependant
on it, will use.</p>
</dd>
<dd>
<p>Example: --kopts=``foo=bar baz=3 asdf''</p>
</dd>
</li>
<dt><strong><a name="item_arch">arch</a></strong>

<dd>
<p>(optional) sets the architecture for the PXE bootloader</p>
</dd>
<dd>
<p>x86 and x86_64 are interchangable, both use syslinux.</p>
</dd>
<dd>
<p>ia64 uses the IA64 build of elilo.</p>
</dd>
<dd>
<p>if you don't use IA64 systems, leaving this parameter off is fine.</p>
</dd>
</li>
<dt><strong><a name="item_ksmeta">ksmeta</a></strong>

<dd>
<p>(optional)</p>
</dd>
<dd>
<p>This is an advanced feature that sets kickstart variables to substitute, thus enabling kickstart files to be treated as templates.</p>
</dd>
<dd>
<p>Example: --ksmeta=``foo=bar baz=3 asdf''</p>
</dd>
<dd>
<p>See the section below on templating.</p>
</dd>
</li>
<dt><strong><a name="item_breed">breed</a></strong>

<dd>
<p>Defaults to ``redhat'', which is a suitable value for Fedora and Centos as well.  Specifying ``suse'' allows the kickstart file parameters to be treated instead like AutoYaST answer files, such that the proper parameters for SuSE answer files
are put on the kernel command line.  Support for other types of distributions is possible in the future.  The file used for the answer file, regardless of
distro breed, is the value used for --kickstart when creating the profile.  See the profile add commands for further information.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="adding_a_profile">ADDING A PROFILE</a></h2>
<p>A profile associates a distribution to additional specialized options, such as a kickstart automation file.  Profiles are the core unit of provisioning and at least one profile must exist for every distribution to be provisioned.  A profile might represent, for instance, a web server or desktop configuration.</p>
<p><strong>cobbler profile add --name=string --distro=string [--kickstart=url] [--kopts=string] [--ksmeta=string] [--virt-name=string] [--virt-file-size=gigabytes] [--virt-ram=megabytes]</strong></p>
<p>Arguments are as listed for distributions, except for the ``arch'' parameter, and with the additions listed below:</p>
<dl>
<dt><strong>name</strong>

<dd>
<p>a descriptive name.  This could be something like ``rhel4webservers'' or ``fc6desktops''.</p>
</dd>
</li>
<dt><strong><a name="item_distro">distro</a></strong>

<dd>
<p>the name of a previously defined cobbler distribution</p>
</dd>
</li>
<dt><strong><a name="item_kickstart">kickstart</a></strong>

<dd>
<p>(optional) an HTTP URL, NFS URL, or local filesystem path to a kickstart file.  Filesystem paths are needed to take advantage of cobbler's kickstart templating features and are therefore recommended.  Kickstart templating is covered in a later section.</p>
</dd>
<dd>
<p>If this parameter is not provided, the kickstart file will default to /etc/cobbler/default.ks (or whatever is set in /var/lib/cobbler/settings).  This file is initially blank, meaning default kickstarts are not automated.  Admins can change the default.ks or can leave it blank.</p>
</dd>
<dd>
<p>Note:  For other breeds of distros (see --breed argument to ``distro add'') that do not use ``kickstarts'', the kickstart in this case is just the distro specific answer file (such as an AutoYAST file).  koan doesn't work for those other distros (like SuSE), but cobbler should be perfectly usable as a stand-alone solution for automated multi-distro-breed PXE control.</p>
</dd>
</li>
<dt><strong><a name="item_virt_2dname">virt-name</a></strong>

<dd>
<p>(optional) (Virt-only) what the Virt guest name should start with.  Creating
multiple images on a machine will cause increasing numbers to be appended to this name.  The default is ``virtguest''.</p>
</dd>
</li>
<dt><strong><a name="item_virt_2dfile_2dsize">virt-file-size</a></strong>

<dd>
<p>(optional) (Virt-only) how large the disk image should be in gigabytes.  The default is ``5''.</p>
</dd>
</li>
<dt><strong><a name="item_virt_2dram">virt-ram</a></strong>

<dd>
<p>(optional) (Virt-only) how many megabytes of RAM to consume.  The default is 512 MB.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="adding_a_system">ADDING A SYSTEM</a></h2>
<p>Systems assign a piece of hardware with the cobbler profile to be assigned to it.  Systems can be defined by hostname, IP, or MAC address.  When available, use of the MAC address to assign systems is preferred.</p>
<p><strong>cobbler system add --name=ip|mac|hostname --profile=string [--kopts=string] [--pxe-address=string] [--ksmeta=string]</strong></p>
<p>Adds a cobbler System to the configuration.  Arguments are specified as per ``profile add'' with
the following changes:</p>
<dl>
<dt><strong>name</strong>

<dd>
<p>The system name must be either a currently-resolvable hostname, an IP address, or a MAC address.</p>
</dd>
<dd>
<p>When defining Virtualized systems, using a MAC address causes the Virt MAC address to be used for creation,
so that is the preferred usage.  To restate this, unless you have a better reason, use the MAC
address here, as it makes things a lot easier and more powerful across the board.</p>
</dd>
<dd>
<p>There is also the magic name ``default'', which allows creation of the default PXE profile.  Without
a ``default'' system name created, PXE will fall through to local boot for unconfigured systems.</p>
</dd>
</li>
<dt><strong><a name="item_pxe_2daddress">pxe-address</a></strong>

<dd>
<p>Advanced feature.</p>
</dd>
<dd>
<p>If cobbler is configured to generate the dhcpd.conf file, use this
setting to pin a certain hostname or IP to a given MAC address.  This corresponds to the ``fixed-address'' field in dhcpd.conf.</p>
</dd>
<dd>
<p>When using this setting for IA64 machines, be sure that the ``--name'' given to the ``system add'' command is a MAC address or no per-system record in dhcpd.conf can be generated.</p>
</dd>
<dd>
<p>Example: ---pxe-address=192.168.1.50</p>
</dd>
<dd>
<p>NOTE: Due to a limitation in elilo (IA64 bootloader), this parameter must ALSO be used even if dhcpd.conf files are not being managed by cobbler AND you want to PXE provision IA64 systems using a handwritten dhcpd.conf.  Also, for IA64, the value of pxe-address must be an IP, and not a hostname, even though hostnames work for X86.  Thankfully, if you don't have IA64 systems, there are a lot less rules.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="adding_a_repository_to_mirror">ADDING A REPOSITORY TO MIRROR</a></h2>
<p>Repository mirroring is one of the more complex cobbler features, though if you want to mirror
a yum repository and integrate it with your provisioning, cobbler can help simplify the required
knowledge a good bit.  If you're just provisioning your home system, ignore this part.</p>
<p><strong>cobbler repo add --mirror=url --mirror-name=string [--local-filename=string]</strong></p>
<dl>
<dt><strong><a name="item_mirror">mirror</a></strong>

<dd>
<p>The addresss of the mirror.  This needs to be either an rsync:// url or an ssh location usable with rsync.
The mirror address should specify an exact repository to mirror -- just one architecture
and just one distribution.  If you have a seperate repo to mirror for a different arch, add that
repo seperately.</p>
</dd>
<dd>
<p>Here's an example of what looks like a good URL:</p>
</dd>
<dd>
<p><a href="rsync://yourmirror.example.com/fedora-linux-core/updates/6/i386">rsync://yourmirror.example.com/fedora-linux-core/updates/6/i386</a> (for rsync protocol)
<a href="mailto:user@yourmirror.example.com/fedora-linux-core/updates/6/i386">user@yourmirror.example.com/fedora-linux-core/updates/6/i386</a>  (for SSH)</p>
</dd>
<dd>
<p>To put it more simply, if the content you are mirroring doesn't contain rpm's
at the top level of the URL, this is bad, and you need to specify a different value.  Using the
wrong mirror value here will rsync over too much data, and also the provisioning integration code
simply won't work.  You can't pass in a Fedora mirror, or even a FC6 mirror address.  Be specific.</p>
</dd>
</li>
<dt><strong><a name="item_mirror_2dname">mirror-name</a></strong>

<dd>
<p>This name is used as the save location for the mirror.  If the mirror represented, say, Fedora Core
6 i386 updates, a good name would be ``fc6i386updates''.  Be explicit.</p>
</dd>
<dd>
<p>This name corresponds with values given to the --repo parameter of ``cobbler profile add''.  If a profile
has a --repo value that matches the name here, that repo can be automatically set up during provisioning.
This means that, if supported by Anaconda, the repo can be used during kickstart install -- and -- either way,
it can be automatically configured on the clients.</p>
</dd>
</li>
<dt><strong><a name="item_local_2dfilename">local-filename</a></strong>

<dd>
<p>Local filename specifies, for kickstarts containing the template parameter ``yum_config_stanza'',
what files to populate on provisioned clients in /etc/yum.repos.d.  In other words, if this value
is ``foo'', the repo would be added on provisioned clients as ``/etc/yum.repos.d/foo.repo''.  If you don't
want clients to have this repo installed, don't add a name for the repo, and provisioned machines
will not configure yum to know about this repo -- you can still do it manually if you choose.</p>
</dd>
<dd>
<p>See /etc/cobbler/kickstart_fc6.ks for an example of how to employ this within a kickstart template.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="displaying_configuration_entries">DISPLAYING CONFIGURATION ENTRIES</a></h2>
<p>This is a rather simple command, usable regardless of how you are using cobbler.</p>
<p><strong>cobbler report [--settings] [--profiles] [--distros] [--systems] [--repos]</strong></p>
<p>Prints the current cobbler configuration for systems, profiles, and groups. If one of the switches is given, only information for those is printed.</p>
<p>The list command gives an abbreviated version of what ``report'' gives.
It only returns the names of each item.</p>
<p><strong>cobbler list [--settings] [--profiles] [--distros] [--systems] [--repos]</strong></p>
<p>Alternatively, you could look at the configuration files in /var/lib/cobbler to see the same information.</p>
<p>
</p>
<h2><a name="deleting_configuration_entries">DELETING CONFIGURATION ENTRIES</a></h2>
<p>If you want to remove a specific object, use the remove command with the name that was used to add it.</p>
<p><strong>cobbler distro remove --name=string</strong></p>
<p><strong>cobbler profile remove --name=string</strong></p>
<p><strong>cobbler system remove --name=string</strong></p>
<p><strong>cobbler remove repo --name=string</strong></p>
<p>
</p>
<h2><a name="rebuilding_configurations">REBUILDING CONFIGURATIONS</a></h2>
<p><strong>cobbler sync</strong></p>
<p>Cobbler sync is used to repair or rebuild the contents /tftpboot or /var/www/cobbler when something has changed behind the scenes.  It brings the filesystem up to date with the configuration as understood by cobbler.</p>
<p>Sync should be run whenever files in /var/www/cobbler are manually edited or when making changes to kickstart files.  In practice, this should not happen often, though running sync too many times does not cause any adverse effects.</p>
<p>If using cobbler to manage a DHCP server (see the advanced section of this manpage), sync does need to be
run after systems are added to regenerate and reload the DHCP configuration.</p>
<p>
</p>
<hr />
<h1><a name="examples">EXAMPLES</a></h1>
<p>
</p>
<h2><a name="import_workflow">IMPORT WORKFLOW</a></h2>
<p>This example shows how to create a provisioning infrastructure from a distribution mirror.
Then a default PXE configuration is created, so that by default systems will PXE boot into 
a fully automated install process for that distribution.</p>
<p>You can use a network rsync mirror or a mounted DVD location.</p>
<p><strong>cobbler check</strong></p>
<p><strong>cobbler import --mirror=rsync://yourfavoritemirror.com/foo --mirror-name=anyname</strong></p>
<p># OR</p>
<p><strong>cobbler import --mirror=/mnt/dvd --mirror-name=anyname</strong></p>
<p># wait for rsync to copy files...</p>
<p><strong>cobbler report</strong></p>
<p><strong>cobbler system add --name=default --profile=name_of_a_profile1</strong></p>
<p><strong>cobbler system add --name=AA:BB:CC:DD:EE:FF --profile=name_of_a_profile2</strong></p>
<p><strong>cobbler sync</strong></p>
<p>
</p>
<h2><a name="normal_workflow">NORMAL WORKFLOW</a></h2>
<p>The following example uses a local kernel and initrd file (already downloaded), and 
shows how profiles would be created using two different kickstarts -- one for a web server
configuration and one for a database server.  Then, a machine is assigned to each profile.</p>
<p><strong>cobbler check</strong></p>
<p><strong>cobbler distro add --name=rhel4u3 --kernel=/dir1/vmlinuz --initrd=/dir1/initrd.img</strong></p>
<p><strong>cobbler distro add --name=fc5 --kernel=/dir2/vmlinuz --initrd=/dir2/initrd.img</strong></p>
<p><strong>cobbler profile add --name=fc5webservers --distro=fc5-i386 --kickstart=/dir4/kick.ks --kopts=``something_to_make_my_gfx_card_work=42,some_other_parameter=foo''</strong></p>
<p><strong>cobbler profile add --name=rhel4u3dbservers --distro=rhel4u3 --kickstart=/dir5/kick.ks</strong></p>
<p><strong>cobbler system add --name=AA:BB:CC:DD:EE:FF --profile=fc5-webservers</strong></p>
<p><strong>cobbler system add --name=AA:BB:CC:DD:EE:FE --profile=rhel4u3-dbservers</strong></p>
<p><strong>cobbler report</strong></p>
<p>
</p>
<h2><a name="repository_mirroring_workflow">REPOSITORY MIRRORING WORKFLOW</a></h2>
<p>The following example shows how to set up a repo mirror for two repositories, and create a profile
that will auto install those repository configurations on provisioned systems using that profile.</p>
<p><strong>cobbler check</strong></p>
<p># set up your cobbler distros here.</p>
<p><strong>cobbler repo add --mirror=rsync://repos.example.com/foo/i386/ --name=magicfooi386</strong></p>
<p><strong>cobbler repo add <a href="mailto:--mirror=root@192.168.1.5:/foo/i386/">--mirror=root@192.168.1.5:/foo/i386/</a> --name=magicbari386</strong></p>
<p><strong>cobbler reposync</strong></p>
<p><strong>cobbler profile add --name=p1 --distro=existing_distro_name --kickstart=/etc/cobbler/kickstart_fc6.ks --repos=``magicfooi386 magicbari386''</strong></p>
<p>See the expanded description towards the bottom of this manpage for further information about
repo management.</p>
<p>
</p>
<h2><a name="xen">XEN</a></h2>
<p>For Virt, be sure the distro uses a Virt kernel and initrd and follow similar steps as above, adding additional parameters as desired:</p>
<p><strong>cobbler distro add --name=fc5virt --kernel=/dir3/vmlinuz --initrd=/dir6/initrd.img</strong></p>
<p>Specify reasonable values for the Virt image size (in GB) and RAM requirements:</p>
<p><strong>cobbler profile add --name=virtwebservers --distro=fc5virt --kickstart=/dir7/kick.ks --virt-file-size=10 --virt-ram=512</strong></p>
<p>And define systems (if desired) using MAC addresses, not IP's or hostnames:</p>
<p><strong>cobbler system add --name=AA:BB:CC:DD:EE:FE --profile=virtwebservers</strong></p>
<p>
</p>
<hr />
<h1><a name="advanced_topics">ADVANCED TOPICS</a></h1>
<p>
</p>
<h2><a name="pxe_menus">PXE MENUS</a></h2>
<p>Cobbler will automatically generate PXE menus for all profiles it has defined.  Running ``cobbler sync'' is required
to generate and update these menus.</p>
<p>To access the menus, type ``menu'' at the ``boot:'' prompt while a system is PXE booting.  If nothing is typed, the network boot 
will default to a local boot.  If ``menu'' is typed, the user can then choose and provision any cobbler profile the system
knows about.</p>
<p>If the association between a system (MAC address) and a profile is already known, it may be more useful to just use
``system add'' commands and declare that relationship in cobbler; however many use cases will prefer having a PXE system, especially when provisioning is done at the same time as installing new physical machines.</p>
<p>If this behavior is not desired, run ``cobbler system add --name=default --profile=plugh'' to default all PXE booting machines to get a new copy of the profile ``plugh''.  To go back to the menu system, run ``cobbler system remove --name=default'' and then ``cobbler sync'' to regenerate the menus.</p>
<p>
</p>
<h2><a name="kickstart_templating">KICKSTART TEMPLATING</a></h2>
<p>The --ksmeta options above require more explanation.</p>
<p>If and only if --kickstart options reference filesystem URLs, --ksmeta allows for templating of the kickstart files
to achieve advanced functions.  If the --ksmeta option for a profile read --ksmeta=``foo=7 bar=llama'', anywhere
in the kickstart file where the string ``TEMPLATE::bar'' appeared would be replaced with the string ``llama''.  (Actually $bar is also replaced, if you prefer that syntax).</p>
<p>To apply these changes, ``cobbler sync'' must be run to generate custom kickstarts for each profile/system.</p>
<p>For NFS and HTTP URLs, the ``--ksmeta'' options will have no effect. This is a good reason to let
cobbler manage your kickstart files, though the URL functionality is provided for integration with
legacy infrastructure, possibly including web apps that already generate kickstarts.</p>
<p>Templated kickstart files are processed by the templating program/package Cheetah, so anything you can do in a Cheetah template can be done to a kickstart template.  Learn more at <a href="http://www.cheetahtemplate.org/learn.html">http://www.cheetahtemplate.org/learn.html</a></p>
<p>When working with Cheetah, be sure to escape any shell macros that look like ``$(this)'' with something like ``\$(this)'' or errors may show up during the sync process.</p>
<p>Should you want to express larger sections of templating (more that can be decently expressed on the command line), you may want to edit /var/lib/cobbler/ files directly.  Keep in mind that changes need to be valid YAML 1.0 syntax and ``cobbler sync'' should be run after making any changes to those files.</p>
<p>
</p>
<h2><a name="dhcp_configuration_management">DHCP CONFIGURATION MANAGEMENT</a></h2>
<p>By default, cobbler does not write a dhcpd.conf and leaves configuration
of DHCP up to the user.  If manage_dhcp is set to 1 in /var/lib/cobbler/settings,
this changes, and cobbler *will* write it's own dhcp.conf file, replacing any dhcpd.conf
that already exists.</p>
<p>The file is based on a template in /etc/cobbler/dhcpd.conf.template -- and must be user edited for
the user's particular networking environment.  Read the file and understand dhcpd.conf files before proceeding.
If you already have dhcpd.conf data that you would like to preserve (say DHCP was manually configured earlier), 
insert the relevant portions of it into the template file.</p>
<p>So, if this manage_dhcp bit is enabled, the following features are enabled:</p>
<p>(A) pinning dhcp hostnames to MAC addresses automatically.
(B) relatively seamless mixing of Itanium and x86/x86_64 machines in a PXE environment</p>
<p>Per-system records in DHCP will only be written if the cobbler system name is a MAC address, so it's recommended that those be used if manage_dhcp is turned on.</p>
<p>Itanium systems names also need to be specified by the MAC address, and their distribution needs to be created with the ``--arch=ia64'' parameter.</p>
<p>The dhcpd.conf file will be updated each time ``cobbler sync'' is run, and not until then, so it is important
to remember to use ``cobbler sync'' when using this feature.</p>
<p>
</p>
<h2><a name="enchant">ENCHANT</a></h2>
<p>While the normal provisioning procedure is either to PXE bare-metal, or use koan to do something else (kickstart an existing system or deploy Virt), cobbler contains yet another option, called ``enchant''.</p>
<p>Enchant takes a configuration that has already been defined (be sure to run ``cobbler sync'' before using ``cobbler enchant'') and applies it to a remote system that might not have koan installed.  Users might want to use this command to replace a server that is being repurposed, or when no PXE environment can be created.</p>
<p>Essentially what enchant does is allow koan to be executed remotely from the cobbler server.  Running ``enchant'' in it's normal mode will replace the operating system of the target machine, so use it with caution.</p>
<p>Usage:  <strong>cobbler enchant --address=ip|hostname --profile=string</strong>
Usage:  <strong>cobbler enchant --address=ip|hostname --system=string</strong></p>
<p>Adding a ``--virt=yes'' to either form will provision a virtualized image rather than reprovisioning
the remote machine.   The default behavior is machine (not virtual) re-provisioning.</p>
<p>Example:  <strong>cobbler enchant --virt=yes --address=192.168.10.10 --profile=fc6xen</strong></p>
<p>
</p>
<h2><a name="importing_trees">IMPORTING TREES</a></h2>
<p>Cobbler can auto-add distributions and profiles from local or remote sources, usually an rsync mirror of the distribution or a mounted DVD.  This can save a lot of time when setting up a new provisioning environment.</p>
<p>Cobbler will try to detect the distribution type and automatically assign kickstarts.  By default, it will provision the system by erasing the hard drive, setting up eth0 for dhcp, and using a default password of ``cobbler''.  If this is undesirable, edit the kickstart files in /etc/cobbler to do something else or change the kickstart setting in the configuration file after cobbler finishes the import.</p>
<p>Example:  <strong>cobbler import --mirror=rsync://mirrorserver.example.com/path/ --mirror-name=fedora</strong></p>
<p>Example:  <strong>cobbler import --mirror=/mnt/dvd --mirror-name=baz</strong></p>
<p>Once imported, run a ``cobbler list'' or ``cobbler report'' to see what you've added.</p>
<p>By default, the rsync operations will exclude PPC content, debug RPMs, and ISO images -- to change what is excluded during an import, see /etc/cobbler/rsync.exclude.</p>
<p>(Note: if you don't have a DVD drive, you can still download a DVD image and use ``losetup'').</p>
<p>
</p>
<h2><a name="default_pxe_boot_behavior">DEFAULT PXE BOOT BEHAVIOR</a></h2>
<p>What happens when PXE booting a system when cobbler has no record
of the system being booted?</p>
<p>By default, cobbler will configure PXE to boot to the contents of
/etc/cobbler/default.pxe, which (if unmodified) will just fall through
to the local boot process.  Administrators can modify this file if they
like to change that behavior.</p>
<p>An easy way to specify a default cobbler profile to PXE boot is to
create a system named ``default''.  This will cause /etc/cobbler/default.pxe
to be ignored.  To restore the previous behavior do a ``cobbler system remove''
on the ``default'' system.</p>
<p><strong>cobbler system add --name=default --profile=boot_this</strong></p>
<p><strong>cobbler system remove --name=default</strong></p>
<p>
</p>
<h2><a name="repo_management">REPO MANAGEMENT</a></h2>
<p>This has already been covered a good bit in the command reference section.</p>
<p>Yum repository management is an optional feature, and is not required to provision through cobbler.
However, if cobbler is configured to mirror certain repositories, it can then be used to associate
profiles with those repositories.  Systems installed under those profiles will then be autoconfigured
to use these repository mirrors in /etc/yum.repos.d, and if supported (Fedora Core 6 and later) these
repositories can be leveraged even within Anaconda.  This can be useful if (A) you have a large
install base, (B) you want fast installation and upgrades for your systems, or (C) have some
extra software not in a standard repository but want provisioned systems to know about that repository.</p>
<p>Make sure there is plenty of space in cobbler's webdir, which defaults to /var/www/cobbler.</p>
<p><strong>cobbler reposync</strong></p>
<p>Cobbler reposync is the command to use to update repos as configured with ``cobbler repo add''.  Mirroring
can take a long time, and usage of cobbler reposync prior to cobbler sync is needed to ensure
provisioned systems have the files they need to actually use the mirrored repositories.  If you just
add repos and never run reposync, the repos will never be mirrored.  This is probably a command
you would want to put on a crontab, though the frequency of that crontab and where the output
goes is left up to the systems administrator.</p>
<p>Repositories that do not need to be updated can be modifed by tweaking the values in /var/lib/cobbler/repos.</p>
<p>
</p>
<h2><a name="kickstart_tracking">KICKSTART TRACKING</a></h2>
<p>Cobbler knows how to keep track of the status of kickstarting machines.</p>
<p><strong>cobbler status</strong></p>
<p>Using the status command will show when cobbler thinks a machine started kickstarting and when it last requested a file.
This is a good way to track machines that may have gone interactive during kickstarts.  Cobbler will also make a special
request in the post section of the kickstart to signal when a machine is finished kickstarting.</p>
<p>To use this feature, the kickstart tree files need to be served via a <a href="http://server/cobbler_track/...">http://server/cobbler_track/...</a> URL, which happens
automatically when using the ``cobbler import'' command to pull in a kickstart tree from an rsync mirror.</p>
<p>If kickstart trees are somewhere else, one can still benefit from the kickstart tracking feature by adding a symlink to 
/var/www/cobbler/localmirror/distroname will allow the kickstarts to be served through the tracking URL mentioned above.   Be sure to use the <a href="http://server/cobbler_track/">http://server/cobbler_track/</a> URL to point to the kickstart tree for each distro you want to track.</p>
<p>
</p>
<h2><a name="tweaking">TWEAKING</a></h2>
<p>Enterprising users can edit the files in /var/lib/cobbler directly versus using the command line.  The repair
mechanism for user error here is to delete the files in /var/lib/cobbler.  There are also a few configuration
files in /etc/cobbler that can be edited.</p>
<p>Running ``cobbler sync'' is required to apply any changes that are made manually.</p>
<p>
</p>
<h2><a name="api">API</a></h2>
<p>Cobbler also makes itself available as a Python API for use by higher level management software.</p>
<p>
</p>
<hr />
<h1><a name="exit_status">EXIT_STATUS</a></h1>
<p>cobbler's command line returns a zero for success and non-zero for failure.</p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Michael DeHaan &lt;<a href="mailto:mdehaan@redhat.com">mdehaan@redhat.com</a>&gt;</p>

</body>

</html>
