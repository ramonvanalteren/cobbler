#!/usr/bin/python

"""
Wrapper for cobbler's remote syslog watching daemon.

Copyright 2006, Red Hat, Inc
Michael DeHaan <mdehaan@redhat.com>

This software may be freely redistributed under the terms of the GNU
general public license.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
"""

import sys
import os
import cobbler.api as bootapi
import cobbler.cobblerd as app
import logging
import cobbler.utils as utils
import cobbler.sub_process as sub_process

import optparse

#logger = logging.getLogger("cobbler.cobblerd")
#logger.setLevel(logging.DEBUG)
#ch = logging.FileHandler("/var/log/cobbler/cobblerd.log")
#ch.setLevel(logging.DEBUG)
#formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
#ch.setFormatter(formatter)
#logger.addHandler(ch)

SELINUX_PUBLIC_PATTERNS = {
   "/var/lib/tftpboot" : "/var/lib/tftpboot/.*",
   "/tftpboot" : "/tftpboot/.*",
   "/var/www/cobbler/images" : "/var/www/cobbler/images/.*",
}

def selinux_setup():

    if not utils.is_selinux_enabled():
        return False

    # install rules that will ensure content we are likely
    # to hardlink between multiple locations gets the right
    # context (public_content_t) instead of httpd_sys_content_t
    # or tftpdir_t

    for x in SELINUX_PUBLIC_PATTERNS.keys():
        y = SELINUX_PUBLIC_PATTERNS[x]
        if os.path.exists(x):
            cmd = [ "/usr/sbin/semanage",
                "fcontext",
                "-a","-t","public_content_t",y
            ]
            print cmd
            rc = sub_process.call(cmd)
            
def daemonize_self(logger):
    # daemonizing code:  http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66012
    logger.info("cobblerd started")
    selinux_setup()
    try: 
        pid = os.fork() 
        if pid > 0:
            # exit first parent
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror) 
        utils.log_exc(logger)
        sys.exit(1)

    # decouple from parent environment
    os.chdir("/") 
    os.setsid() 
    os.umask(0) 

    # do second fork
    try: 
        pid = os.fork() 
        if pid > 0:
            # print "Daemon PID %d" % pid 
            sys.exit(0) 
    except OSError, e: 
        print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror) 
        utils.log_exc(logger)
        sys.exit(1) 

    dev_null = file('/dev/null','rw') 
    os.dup2(dev_null.fileno(), sys.stdin.fileno()) 
    os.dup2(dev_null.fileno(), sys.stdout.fileno()) 
    os.dup2(dev_null.fileno(), sys.stderr.fileno()) 

def main():
    op = optparse.OptionParser()
    op.set_defaults(daemonize=True, log_level=None)
    op.add_option('-B', '--daemonize', dest='daemonize', action='store_true',
        help='run in background (default)')
    op.add_option('-F', '--no-daemonize', dest='daemonize', action='store_false',
        help='run in foreground (do not daemonize)')
    op.add_option('-f', '--log-file', dest='log_file', metavar='NAME',
        help='file to log to')
    op.add_option('-l', '--log-level', dest='log_level', metavar='LEVEL',
        help='log level (ie. INFO, WARNING, ERROR, CRITICAL)')

    options, args = op.parse_args()

    log_settings = {}
    if options.log_file:
        log_settings['log_file'] = options.log_file
    if options.log_level:
        log_level = logging.getLevelName(options.log_level)
        if not isinstance(log_level, int):
            op.error('Unrecognized log level %r given')
        log_settings['log_level'] = log_level
    api = bootapi.BootAPI(log_settings=log_settings)
    logger = api.logger

    if options.daemonize:
        daemonize_self(logger)

    try:
        app.core(logger=logger)
    except:
        utils.log_exc(logger)

if __name__ == "__main__":
    main()
